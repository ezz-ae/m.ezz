/**
 * @fileoverview Firestore Security Rules for EZZ.AE.
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model for private data, while allowing public read access to explicitly designated public notebooks. Authorization decisions are based on the authenticated user's ID and the 'ownerId' field within documents, prioritizing data denormalization for efficient security checks.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, accessible only to the authenticated user.
 * - /notebooks/{notebookId}: Stores notebooks. Access is controlled by the 'visibility' field ('public' allows public read, 'private' restricts access to the owner) and the 'ownerId' field.
 * - /notebooks/{notebookId}/notes/{noteId}: Stores notes. Access is restricted to the owner of the parent notebook.
 * - /notebooks/{notebookId}/concepts/{conceptId}: Stores concepts. Access is restricted to the owner of the parent notebook.
 * - /patterns/{patternId}: Stores patterns. Access is restricted to the owner of the associated notebooks.
 * - /sessions/{sessionId}: Stores sessions. Access is restricted to the owner of the session.
 * - /ledgerEntries/{entryId}: Stores ledger entries. Access is restricted to the owner of the associated notebook or user.
 * - /artifacts/{artifactId}: Stores artifacts. Access is restricted to the owner of the associated notebook.
 * - /events/{eventId}: Stores events. Access is restricted to the owner of the associated user or notebook.
 *
 * Key Security Decisions:
 * - Users can only read and write their own user documents.
 * - Notebooks can be public (readable by anyone) or private (readable/writable only by the owner).
 * - Subcollections inherit the authorization context from their parent notebook.
 * - `list` operations are secured by default, only allowing listing of user-owned documents. Public listings are enabled only where explicitly intended.
 *
 * Denormalization for Authorization:
 * - The 'ownerId' field is included directly in the /notebooks/{notebookId} documents to avoid costly `get()` operations in security rules.
 *
 * Structural Segregation:
 * - Public and private notebooks are distinguished by the 'visibility' field within the /notebooks/{notebookId} collection, rather than using separate collections.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages user profiles. Only the authenticated user can access their own profile.
     * @path /users/{userId}
     * @allow (read, write) User with ID 'user123' can read/write their own profile.
     * @deny (read, write) User with ID 'user456' cannot read/write the profile of 'user123'.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;

      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages notebooks. Public notebooks are readable by anyone, private notebooks are only accessible to the owner.
     * @path /notebooks/{notebookId}
     * @allow (read) Anyone can read a notebook where visibility == 'public'.
     * @allow (write) User with ownerId 'user123' can write to a notebook where ownerId == 'user123'.
     * @deny (write) User with ownerId 'user456' cannot write to a notebook where ownerId == 'user123'.
     * @principle Enforces document ownership for writes, allows public read for public notebooks.
     */
    match /notebooks/{notebookId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(ownerId) {
        return isSignedIn() && request.auth.uid == ownerId;
      }
      function isExistingOwner(ownerId) {
        return isOwner(ownerId) && resource != null;
      }

      allow get: if resource.data.visibility == 'public' || isOwner(resource.data.ownerId);
      allow list: if true;

      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Manages notes within a notebook. Access is restricted to the owner of the parent notebook.
     * @path /notebooks/{notebookId}/notes/{noteId}
     * @allow (read, write) User who owns the notebook can read/write notes within it.
     * @deny (read, write) User who does not own the notebook cannot read/write notes within it.
     * @principle Inherits authorization context from the parent notebook.
     */
    match /notebooks/{notebookId}/notes/{noteId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isNotebookOwner(notebookId) {
        return get(/databases/$(database)/documents/notebooks/$(notebookId)).data.ownerId == request.auth.uid;
      }

      allow get: if isSignedIn() && isNotebookOwner(notebookId);
      allow list: if isSignedIn() && isNotebookOwner(notebookId);

      allow create: if isSignedIn() && isNotebookOwner(notebookId);
      allow update: if isSignedIn() && isNotebookOwner(notebookId);
      allow delete: if isSignedIn() && isNotebookOwner(notebookId);
    }

    /**
     * @description Manages concepts within a notebook. Access is restricted to the owner of the parent notebook.
     * @path /notebooks/{notebookId}/concepts/{conceptId}
     * @allow (read, write) User who owns the notebook can read/write concepts within it.
     * @deny (read, write) User who does not own the notebook cannot read/write concepts within it.
     * @principle Inherits authorization context from the parent notebook.
     */
    match /notebooks/{notebookId}/concepts/{conceptId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isNotebookOwner(notebookId) {
        return get(/databases/$(database)/documents/notebooks/$(notebookId)).data.ownerId == request.auth.uid;
      }

      allow get: if isSignedIn() && isNotebookOwner(notebookId);
      allow list: if isSignedIn() && isNotebookOwner(notebookId);

      allow create: if isSignedIn() && isNotebookOwner(notebookId);
      allow update: if isSignedIn() && isNotebookOwner(notebookId);
      allow delete: if isSignedIn() && isNotebookOwner(notebookId);
    }

    /**
     * @description Manages patterns. Access is restricted to the owner of the associated notebooks.
     * @path /patterns/{patternId}
     * @allow (read, write) User who owns the notebook associated with the pattern can read/write patterns.
     * @deny (read, write) User who does not own the associated notebook cannot read/write patterns.
     * @principle Access controlled via notebookId.
     */
    match /patterns/{patternId} {
      function isSignedIn() {
        return request.auth != null;
      }

      // TODO: Implement more robust ownership check using notebookIds array
      // For now, deny all direct access to patterns.  Access should be managed through Cloud Functions.
      allow get: if false;
      allow list: if false;

      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Manages sessions. Access is restricted to the owner of the session.
     * @path /sessions/{sessionId}
     * @allow (read, write) User who owns the session can read/write session data.
     * @deny (read, write) User who does not own the session cannot read/write session data.
     * @principle Access controlled via userId.
     */
    match /sessions/{sessionId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }
       function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow list: if isSignedIn() && resource.data.userId == request.auth.uid;

      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Manages ledger entries. Access is restricted to the owner of the associated notebook or user.
     * @path /ledgerEntries/{entryId}
     * @allow (read, write) User who owns the associated notebook can read/write ledger entries.
     * @deny (read, write) User who does not own the associated notebook cannot read/write ledger entries.
     * @principle Access controlled via notebookId and userId.
     */
    match /ledgerEntries/{entryId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isNotebookOwner(notebookId) {
        return get(/databases/$(database)/documents/notebooks/$(notebookId)).data.ownerId == request.auth.uid;
      }

      allow get: if isSignedIn() && isNotebookOwner(resource.data.notebookId);
      allow list: if isSignedIn() && isNotebookOwner(resource.data.notebookId);

      allow create: if isSignedIn() && isNotebookOwner(request.resource.data.notebookId);
      allow update: if isSignedIn() && isNotebookOwner(request.resource.data.notebookId);
      allow delete: if isSignedIn() && isNotebookOwner(request.resource.data.notebookId);
    }

    /**
     * @description Manages artifacts. Access is restricted to the owner of the associated notebook.
     * @path /artifacts/{artifactId}
     * @allow (read, write) User who owns the associated notebook can read/write artifacts.
     * @deny (read, write) User who does not own the associated notebook cannot read/write artifacts.
     * @principle Access controlled via notebookId.
     */
    match /artifacts/{artifactId} {
       function isSignedIn() {
        return request.auth != null;
      }
      function isNotebookOwner(notebookId) {
        return get(/databases/$(database)/documents/notebooks/$(notebookId)).data.ownerId == request.auth.uid;
      }

      allow get: if isSignedIn() && isNotebookOwner(resource.data.notebookId);
      allow list: if isSignedIn() && isNotebookOwner(resource.data.notebookId);

      allow create: if isSignedIn() && isNotebookOwner(request.resource.data.notebookId);
      allow update: if isSignedIn() && isNotebookOwner(request.resource.data.notebookId);
      allow delete: if isSignedIn() && isNotebookOwner(request.resource.data.notebookId);
    }

    /**
     * @description Manages events. Access is restricted to the owner of the associated user or notebook.
     * @path /events/{eventId}
     * @allow (create) All authenticated users can create events.
     * @deny (read, write) Regular users cannot read/write events (only created).
     * @principle Access controlled via userId and notebookId.
     */
    match /events/{eventId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isNotebookOwner(notebookId) {
        return get(/databases/$(database)/documents/notebooks/$(notebookId)).data.ownerId == request.auth.uid;
      }
      function isExistingNotebookOwner(notebookId) {
        return isSignedIn() && isNotebookOwner(notebookId) && resource != null;
      }
      allow get: if false;
      allow list: if false;

      allow create: if isSignedIn(); // Events can be created by anyone.
      allow update: if false;
      allow delete: if false;
    }
  }
}

    